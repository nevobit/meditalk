# GraphQL API

Our GraphQL API provides a flexible and efficient way to query and mutate data. Built with Apollo Server, it offers a single endpoint for all data operations.

## Endpoint

```
POST /graphql
```

## Schema Overview

Our GraphQL schema is auto-generated from TypeScript types and includes:

- **Queries**: Data fetching operations
- **Mutations**: Data modification operations
- **Subscriptions**: Real-time updates (WebSocket)

## Authentication

GraphQL uses JWT tokens for authentication. Include the token in the Authorization header:

```typescript
const headers = {
  Authorization: 'Bearer <your-jwt-token>',
  'Content-Type': 'application/json',
};
```

## Basic Queries

### Fetch User Profile

```graphql
query GetUser($id: ID!) {
  user(id: $id) {
    id
    name
    email
    profile {
      avatar
      bio
      location
    }
    createdAt
    updatedAt
  }
}
```

**Variables:**

```json
{
  "id": "user-123"
}
```

### Fetch Users with Pagination

```graphql
query GetUsers($first: Int, $after: String) {
  users(first: $first, after: $after) {
    edges {
      node {
        id
        name
        email
      }
      cursor
    }
    pageInfo {
      hasNextPage
      hasPreviousPage
      startCursor
      endCursor
    }
    totalCount
  }
}
```

**Variables:**

```json
{
  "first": 10,
  "after": "cursor-123"
}
```

## Basic Mutations

### Create User

```graphql
mutation CreateUser($input: CreateUserInput!) {
  createUser(input: $input) {
    id
    name
    email
    createdAt
  }
}
```

**Variables:**

```json
{
  "input": {
    "name": "John Doe",
    "email": "john@example.com",
    "password": "secure-password"
  }
}
```

### Update User

```graphql
mutation UpdateUser($id: ID!, $input: UpdateUserInput!) {
  updateUser(id: $id, input: $input) {
    id
    name
    email
    updatedAt
  }
}
```

**Variables:**

```json
{
  "id": "user-123",
  "input": {
    "name": "John Smith",
    "bio": "Updated bio"
  }
}
```

### Delete User

```graphql
mutation DeleteUser($id: ID!) {
  deleteUser(id: $id) {
    id
    success
    message
  }
}
```

## Advanced Queries

### Nested Queries

```graphql
query GetUserWithPosts($userId: ID!) {
  user(id: $userId) {
    id
    name
    email
    posts {
      id
      title
      content
      publishedAt
      comments {
        id
        content
        author {
          name
        }
      }
    }
  }
}
```

### Filtering and Sorting

```graphql
query GetPosts($filter: PostFilter, $sort: PostSort) {
  posts(filter: $filter, sort: $sort) {
    id
    title
    content
    author {
      name
    }
    publishedAt
  }
}
```

**Variables:**

```json
{
  "filter": {
    "published": true,
    "authorId": "user-123"
  },
  "sort": {
    "field": "PUBLISHED_AT",
    "direction": "DESC"
  }
}
```

### Search

```graphql
query SearchPosts($query: String!, $first: Int) {
  searchPosts(query: $query, first: $first) {
    id
    title
    content
    author {
      name
    }
    score
  }
}
```

## Real-time Subscriptions

### User Activity

```graphql
subscription UserActivity($userId: ID!) {
  userActivity(userId: $userId) {
    type
    data
    timestamp
  }
}
```

### New Posts

```graphql
subscription NewPosts {
  newPosts {
    id
    title
    author {
      name
    }
    publishedAt
  }
}
```

## Error Handling

GraphQL provides structured error responses:

```json
{
  "data": null,
  "errors": [
    {
      "message": "User not found",
      "locations": [
        {
          "line": 2,
          "column": 3
        }
      ],
      "path": ["user"],
      "extensions": {
        "code": "USER_NOT_FOUND",
        "userId": "invalid-id"
      }
    }
  ]
}
```

### Common Error Codes

- `UNAUTHENTICATED` - Authentication required
- `FORBIDDEN` - Insufficient permissions
- `NOT_FOUND` - Resource not found
- `VALIDATION_ERROR` - Input validation failed
- `INTERNAL_ERROR` - Server error

## Rate Limiting

GraphQL endpoints are rate-limited:

- **Authenticated users**: 1000 requests/hour
- **Unauthenticated users**: 100 requests/hour
- **Complex queries**: Additional limits based on query complexity

Rate limit headers are included in responses:

```
X-RateLimit-Limit: 1000
X-RateLimit-Remaining: 999
X-RateLimit-Reset: 1640995200
```

## Query Complexity

Complex queries are analyzed to prevent abuse:

```graphql
# This query has complexity 5
query SimpleQuery {
  user(id: "123") {
    # +1
    posts {
      # +2
      comments {
        # +2
        author {
          # +0 (already loaded)
          name
        }
      }
    }
  }
}
```

Maximum complexity: 1000 points per query.

## Caching

### HTTP Caching

Use HTTP cache headers for query results:

```http
Cache-Control: public, max-age=300
ETag: "abc123"
```

### Client-Side Caching

Apollo Client provides automatic caching:

```typescript
import { ApolloClient, InMemoryCache } from '@apollo/client';

const client = new ApolloClient({
  uri: 'https://api.repo.com/graphql',
  cache: new InMemoryCache({
    typePolicies: {
      User: {
        keyFields: ['id'],
        fields: {
          posts: {
            merge: false,
          },
        },
      },
    },
  }),
});
```

## Introspection

The schema supports introspection for tooling:

```graphql
query IntrospectionQuery {
  __schema {
    types {
      name
      description
      fields {
        name
        type {
          name
        }
      }
    }
  }
}
```

## Development Tools

### GraphQL Playground

Access the interactive playground at:

```
https://api.repo.com/graphql
```

### Apollo Studio

Use Apollo Studio for schema exploration and query testing.

### VS Code Extensions

Recommended extensions:

- GraphQL: Language Feature Support
- GraphQL: Syntax Highlighting
- Apollo GraphQL

## SDK Integration

### JavaScript/TypeScript SDK

```typescript
import { GtallaSDK } from '{{packageName}}/sdk';

const sdk = new GtallaSDK({
  apiKey: 'your-api-key',
  environment: 'production',
});

// Execute a query
const result = await sdk.graphql.query({
  query: GET_USER,
  variables: { id: 'user-123' },
});

// Execute a mutation
const result = await sdk.graphql.mutate({
  mutation: CREATE_USER,
  variables: { input: userData },
});
```

### React Hooks

```typescript
import { useQuery, useMutation } from '@apollo/client';

function UserProfile({ userId }) {
  const { loading, error, data } = useQuery(GET_USER, {
    variables: { id: userId }
  });

  const [updateUser] = useMutation(UPDATE_USER);

  if (loading) return <p>Loading...</p>;
  if (error) return <p>Error: {error.message}</p>;

  return (
    <div>
      <h1>{data.user.name}</h1>
      <button onClick={() => updateUser({ variables: { id: userId, input: { name: 'New Name' } } })}>
        Update Name
      </button>
    </div>
  );
}
```

## Best Practices

### Query Optimization

1. **Request only needed fields**
2. **Use pagination for large datasets**
3. **Implement query complexity analysis**
4. **Cache frequently accessed data**

### Error Handling

1. **Handle network errors gracefully**
2. **Provide user-friendly error messages**
3. **Log errors for debugging**
4. **Implement retry logic for transient failures**

### Security

1. **Validate all inputs**
2. **Implement proper authentication**
3. **Use query complexity limits**
4. **Sanitize error messages**

## Schema Evolution

### Backward Compatibility

- **Additive changes** are always safe
- **Deprecation** process for breaking changes
- **Versioning** for major schema changes
- **Migration guides** for clients

### Deprecation Process

1. **Mark fields as deprecated**
2. **Provide migration path**
3. **Maintain for 12 months**
4. **Remove in next major version**

---

For more information about specific types and operations, see the **[GraphQL Schema Reference](./schema)**.
